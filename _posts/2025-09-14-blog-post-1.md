---
title: 'Anatomy of a Lock-Free Algorithm'
date: 2025-09-14
permalink: /posts/anatomy-of-a-lock-free-algorithm/
tags:
  - lock free data structures
  - graph algorithms
---

In this post, I'll describe lock-free implementations of 2 graph algorithms: (i) shortest path (ii) variable length
recursive join queries. This is the first part of two blog posts and is meant to be companion to my [VLDB '25 paper](https://arxiv.org/abs/2508.19379)
on parallelizing recursive queries in graph databases. The paper focuses more on efficient scheduling policies at the database physical operator level.
But we did not really get a chance to describe _how we parallelize the graph algorithms itself_ (section 4.2 in the paper provides some details).

Since *most* people don't have a background in graph database algorithms or what "lock-free" even means, I have a background section
on this. The two algorithms I describe here are on the opposite end of the spectrum. The (unweighted) shortest path query returning only
the path lengths is relatively easy in terms of what we need to keep track of and how to parallelize. The variable length path query (walk semantics) returning paths
is the most expensive (compute & memory wise) and complicated query you could ask a graph database to execute. At the end I also have a section
on what challenges we faced while running these queries, and how beneficial lock-free algorithms really are in practice. 

# Table of Contents
1. [Background](#Background)
2. [Shortest Path](#Shortest Path)
3. [Variable Length Path](#Variable Length Path)
4. [So ... what's the catch ?](#fourth-examplehttpwwwfourthexamplecom)


## Background


## Shortest Path


## Variable Length Path


## So ... what's the catch ?




