---
title: 'Anatomy of a Lock-Free Algorithm'
date: 2025-09-14
permalink: /posts/anatomy-of-a-lock-free-algorithm/
tags:
  - lock free data structures
  - graph algorithms
---

In this post, I'll describe lock-free implementations of 2 graph algorithms: (i) shortest path (ii) variable length
recursive join queries. This is the first part of two blog posts and is meant to be companion to my [VLDB '25 paper](https://arxiv.org/abs/2508.19379)
on parallelizing recursive queries in graph databases. The paper focuses more on efficient scheduling policies at the database physical operator level.
But we did not really get a chance to describe _how we parallelize the graph algorithms itself_ (section 4.2 in the paper provides some details).

// add a table right in the beginning to convey the importance / significance of work

Since *most* people don't have a background in graph database algorithms or what "lock-free" even means, I have a background section
on this. The two algorithms I describe here are on the opposite end of the spectrum. The (unweighted) shortest path query returning only
the path lengths is relatively easy in terms of what we need to keep track of and how to parallelize. The variable length path query (walk semantics) returning paths
is the most expensive (compute & memory wise) and complicated query you could ask a graph database to execute. At the end I also have a section
on what challenges we faced while running these queries, and how beneficial lock-free algorithms really are in practice. 


# Table of Contents
1. [Background](#Background)
2. [Shortest Path](#Shortest Path)
3. [Variable Length Path](#Variable Length Path)
4. [So,what's the catch?](#So,what's the catch?)


## Background

It's 2025, and most graph databases now support Cypher as a query language (finally some consolidation here).
Expressing many-to-many joins (queries with long join query patterns) or recursive queries in Cypher is way more intuitive.
When I say "recursive queries" here, I am referring to queries that involve repeated number of joins until a condition is satisfied.
The condition can be for example, encountering a particular node / row while (shortest path) or reaching a particular join depth (variable length).
In Cypher, if you wanted to write the unweighted shortest path query, and return the path length, this would be the syntax:

```
MATCH p = (a:Person)-[r:Knows* SHORTEST 1..30]->(b:Person)
WHERE a.name = 'Alice' AND b.name = 'Bob'  
RETURN length(p)
```

The above query would take the node 'Alice', explore who Alice knows (1 join) then explore their neighbours (2 joins) and keep
going until we hit 'Bob'. Since 


```
MATCH p = (a:Person)-[r:Knows* 1..10]->(b:Person)    
WHERE a.name = 'Alice' AND b.name = 'Bob'  
RETURN length(p)
```

Let's take the following graph as an example (we'll keep using this as a running example):

<figure>
  <img src="/images/graph.png" alt="Description" style="width: 100%;" />
  <figcaption style="text-align: center;">Example Graph</figcaption>
</figure>




## Shortest Path


## Variable Length Path


## So,what's the catch?



