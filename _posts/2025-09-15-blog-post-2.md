---
title: 'Down the Rabbit Hole with Perf'
date: 2025-09-15
permalink: /posts/down-the-rabbit-hole-with-perf/
tags:
  - lock free data structures
  - graph algorithms
---

In my previous [post](https://anuchak.github.io/posts/anatomy-of-a-lock-free-algorithm/), I described
the implementation of two lock-free algorithms for recursive queries in graph databases that achieved speedup
through atomic operations and parallel BFS traversals. In this post, I will share some interesting performance
findings I encountered while optimizing both algorithms using Linux `Perf`.

Tuning code for performance is never straightforward. It requires an intricate understanding of the what's
happening under the hood, knowing where to look, and knowing the right tool to use. Linux `Perf` is a powerful
tool for this job - it provides rich metrics about CPU cycles, cache misses, TLB misses, branch predictions, and
more. If you're looking for a deeper dive on `Perf`, I recommend this [tutorial](https://github.com/NAThompson/performance_tuning_tutorial).

This post is divided into four sections. The first section briefly describes the algorithms we will tune for performance,
and the scheduling policy that runs them in KÃ¹zu (more details in the [VLDB '25 paper](https://arxiv.org/abs/2508.19379)).
The next two sections describe interesting performance findings: Section 2 describes how a parameter introduced
too much concurrency leading to performance degradation and Section 3 describes how `Perf` revealed a performance 
bottleneck and prefetching helps to tackle it. The final section, similar to the previous post, discusses certain
hardware requirements for performing such low-level optimizations.

# Table of Contents
1. [Background](#Background)
2. [The curious case of 'k'](#the-curious-case-of-k)
3. [Prefetching at Lightspeed](#prefetching-at-lightspeed)
4. [So, what's the catch?](#so-whats-the-catch)


## Background


## The curious case of 'k'


## Prefetching at Lightspeed


## So, what's the catch?


